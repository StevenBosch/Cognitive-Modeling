t_s = priorDists[[priorDist]][sample] # The current sample time
# Measure the interval in ticks
timeToTicks(sample)
# Using the previously defined prior determine the estimated time and produced time
}
}
}
}
readySetGo(nrSubjects, trainingTrials, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
activation
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trainingTrials = 500 # The number of learning trials
trials = 1000 # The number of test trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
#
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsTrainData = array(NA, dim = c(nrSubjects, length(priorDists), trainingTrials))
subjectsTestData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trainingTrials, trials) {
for(subject in 1:nrSubjects) {
# Create the declarative memory of the current subject
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trainingTrials+trials))
activation = array(NA, dim=c(trainingTrials+trials))
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
for(tTrial in 1:trainingTrials) {
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
t_m = ticksToTime(timeToTicks(t_s)) # Measure the sample time
delay = sample(250:850, 1) # In the experiment the delay was a random value betwen 250 and 850 ms
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time of the sample to the chunk of the current condition (measured with timeToTicks and ticksToTime)
DM = add.encounter(DM, 1, curtime)
# Store t_m
measuredTimes[tTrial] = t_m
# Calculate activation values for all encounters so far using their
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
}
curtime = 0
for(trial in 1:trials){
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
# Measure the interval in ticks
timeToTicks(sample)
# Using the previously defined prior determine the estimated time and produced time
}
}
}
}
readySetGo(nrSubjects, trainingTrials, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
activation
readySetGo(nrSubjects, trainingTrials, trials)
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trainingTrials+trials))
activation = array(NA, dim=c(trainingTrials+trials))
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
for(tTrial in 1:trainingTrials) {
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
t_m = ticksToTime(timeToTicks(t_s)) # Measure the sample time
delay = sample(250:850, 1) # In the experiment the delay was a random value betwen 250 and 850 ms
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time of the sample to the chunk of the current condition (measured with timeToTicks and ticksToTime)
DM = add.encounter(DM, 1, curtime)
# Store t_m
measuredTimes[tTrial] = t_m
# Calculate activation values for all encounters so far using their
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
}
}
activationo
activation
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trainingTrials = 500 # The number of learning trials
trials = 1000 # The number of test trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
#
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsTrainData = array(NA, dim = c(nrSubjects, length(priorDists), trainingTrials))
subjectsTestData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trainingTrials, trials) {
for(subject in 1:nrSubjects) {
# Create the declarative memory of the current subject
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trainingTrials+trials))
activation = array(NA, dim=c(trainingTrials+trials))
priors = array(NA, dim=c(trainingTrials+trials))
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
for(tTrial in 1:trainingTrials) {
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
t_m = ticksToTime(timeToTicks(t_s)) # Measure the sample time
delay = sample(250:850, 1) # In the experiment the delay was a random value betwen 250 and 850 ms
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time of the sample to the chunk of the current condition (measured with timeToTicks and ticksToTime)
DM = add.encounter(DM, 1, curtime)
# Store t_m
measuredTimes[tTrial] = t_m
# Calculate activation values for all encounters so far using their
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
}
curtime = 0
for(trial in 1:trials){
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
# Measure the interval in ticks
timeToTicks(sample)
# Using the previously defined prior determine the estimated time and produced time
}
}
}
}
readySetGo(nrSubjects, trainingTrials, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trainingTrials+trials))
activation = array(NA, dim=c(trainingTrials+trials))
priors = array(NA, dim=c(trainingTrials+trials))
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
for(tTrial in 1:trainingTrials) {
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
t_m = ticksToTime(timeToTicks(t_s)) # Measure the sample time
delay = sample(250:850, 1) # In the experiment the delay was a random value betwen 250 and 850 ms
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time of the sample to the chunk of the current condition (measured with timeToTicks and ticksToTime)
DM = add.encounter(DM, 1, curtime)
# Store t_m
measuredTimes[tTrial] = t_m
# Calculate activation values for all encounters so far using their
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
}
}
activationo
activation
estimatedTime = sum(priors*measuredTimes)
estimatedTime
priors
for(encounter in 1:sum(!is.na(measuredTimes))) {
priors[encounter] = activation[encounter] / activationSum
}
activationSum = sum(activation)
# Calculate the priors
for(encounter in 1:sum(!is.na(measuredTimes))) {
priors[encounter] = activation[encounter] / activationSum
}
# Determine the estimated time
estimatedTime = sum(priors*measuredTimes)
estimatedTime
subjectsData[subject][priorDist][trial] = sum(priors*measuredTimes)
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
#
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trials) {
for(subject in 1:nrSubjects) {
# Create the declarative memory of the current subject
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trials))
activation = array(NA, dim=c(trials))
priors = array(NA, dim=c(trials))
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time
t_m = ticksToTime(timeToTicks(t_s))
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter
DM = add.encounter(DM, 1, curtime)
# Store the measured duration time on the same index as the encounter is added to the DM to link the two
measuredTimes[trial] = t_m
# Calculate activation values for all encounters so far using the current time and the time of the encounter
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
# Calculate the priors with the activations
activationSum = sum(activation)
for(encounter in 1:sum(!is.na(measuredTimes))) {
priors[encounter] = activation[encounter] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject][priorDist][trial] = sum(priors*measuredTimes)
}
}
}
}
readySetGo(nrSubjects, trainingTrials, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
#
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trials) {
for(subject in 1:nrSubjects) {
# Create the declarative memory of the current subject
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trials))
activation = array(NA, dim=c(trials))
priors = array(NA, dim=c(trials))
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time
t_m = ticksToTime(timeToTicks(t_s))
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter
DM = add.encounter(DM, 1, curtime)
# Store the measured duration time on the same index as the encounter is added to the DM to link the two
measuredTimes[trial] = t_m
# Calculate activation values for all encounters so far using the current time and the time of the encounter
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
# Calculate the priors with the activations
activationSum = sum(activation)
for(encounter in 1:sum(!is.na(measuredTimes))) {
priors[encounter] = activation[encounter] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject][priorDist][trial] = sum(priors*measuredTimes)
}
}
}
}
readySetGo(nrSubjects, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
warnings()
subjectsData
subjectsData[1]
subjectsData[[1]]
subjectsData[[[1]]]
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trials))
activation = array(NA, dim=c(trials))
priors = array(NA, dim=c(trials))
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time
t_m = ticksToTime(timeToTicks(t_s))
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter
DM = add.encounter(DM, 1, curtime)
# Store the measured duration time on the same index as the encounter is added to the DM to link the two
measuredTimes[trial] = t_m
# Calculate activation values for all encounters so far using the current time and the time of the encounter
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
# Calculate the priors with the activations
activationSum = sum(activation)
for(encounter in 1:sum(!is.na(measuredTimes))) {
priors[encounter] = activation[encounter] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject][priorDist][trial] = sum(priors*measuredTimes)
}
}
subject = 1
subjectsData[subject][priorDist][trial] = sum(priors*measuredTimes)
subjectsData[subject][priorDist][trial] = sum(priors*measuredTimes)
subjectsData
subjectsData[1][1][400]
subjectsData[1][1][1]
priors
t_s = priorDists[[priorDist]][sample(1:11, 1)]
t_s
t_m = ticksToTime(timeToTicks(t_s))
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter
DM = add.encounter(DM, 1, curtime)
# Store the measured duration time on the same index as the encounter is added to the DM to link the two
measuredTimes[trial] = t_m
# Calculate activation values for all encounters so far using the current time and the time of the encounter
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
activation
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time
t_m = ticksToTime(timeToTicks(t_s))
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter
DM = add.encounter(DM, 1, curtime)
# Store the measured duration time on the same index as the encounter is added to the DM to link the two
measuredTimes[trial] = t_m
# Calculate activation values for all encounters so far using the current time and the time of the encounter
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
# Calculate the priors with the activations
activationSum = sum(activation)
for(encounter in 1:sum(!is.na(measuredTimes))) {
priors[encounter] = activation[encounter] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject][priorDist][trial] = sum(priors*measuredTimes)
}
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
#
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trials) {
for(subject in 1:nrSubjects) {
# Create the declarative memory of the current subject
num.chunks = 1
max.num.encounters = 2000
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
measuredTimes = array(NA, dim=c(trials))
activation = array(NA, dim=c(trials))
priors = array(NA, dim=c(trials))
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time
t_m = ticksToTime(timeToTicks(t_s))
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_m # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter
DM = add.encounter(DM, 1, curtime)
# Store the measured duration time on the same index as the encounter is added to the DM to link the two
measuredTimes[trial] = t_m
# Calculate activation values for all encounters so far using the current time and the time of the encounter
for(encounter in 1:sum(!is.na(measuredTimes))) {
activation[encounter] = actr.B(DM[encounter], curtime)
}
# Calculate the priors with the activations
activationSum = sum(activation)
for(encounter in 1:sum(!is.na(measuredTimes))) {
priors[encounter] = activation[encounter] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject][priorDist][trial] = sum(na.rm(priors)*na.rm(measuredTimes))
}
}
}
}
readySetGo(nrSubjects, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
prod(c(1,2,3), c(4,5,6))
x = c(1,2,3)
y = c(4,5,6)
x * y
subjectsData[subject][priorDist][trial] = sum(na.omit(priors)*na.omit(measuredTimes))
priors
measuredTimes
sum(na.omit(priors)*na.omit(measuredTimes))
subjectsData[1][1][500] = sum(na.omit(priors)*na.omit(measuredTimes))
subjectsData[1][1][500]
subjectsData[[1]][1][500]
subjectsData[[1]][[1]][500]
subjectsData[[1]][[1]][500] = sum(na.omit(priors)*na.omit(measuredTimes))
subjectsData[[1]][1][500] = sum(na.omit(priors)*na.omit(measuredTimes))
subjectsData[[1,1,500] = sum(na.omit(priors)*na.omit(measuredTimes))
subjectsData[[1,1,500]
s
