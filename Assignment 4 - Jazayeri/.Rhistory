actr.B <- function(encounters,curtime) {
if (length(curtime)>1) {
sapply(curtime,function(X) { actr.B(encounters,X)})
} else {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
}
actr.B.optimized <- function(n,Time,curtime=NULL) {
if (is.null(curtime)) {
log(n/(1-params$d)) - params$d * log(Time)
} else {
n <- curtime/Time * n
log(n/(1-params$d)) - params$d * log(curtime)
}
}
## ---------------------------------------------------------------------------
## Some example code to get you started:
params$num.chunks <- 4
params$max.num.encounters <- 100
params$duration <- 1000
## Create a DM with room for num.chunks chunks with up to num.encounters encounters per chunk.
DM <- create.dm(params$num.chunks,params$max.num.encounters)
## Add 100 encounters to DM
for (i in 1:250) {
DM <- add.encounter(DM,letters[trunc(runif(1,1,params$num.chunks+1))],runif(1,0,params$duration))
}
## Calculate the activation per chunk:
for (i in letters[1:params$num.chunks]) {
cat("Activation of chunk ",i," is ");
cat(actr.B(get.encounters(DM,i),params$duration),"\n");
}
## ---------------------------------------------------------------------------
##
## What you have to do:
##
## Write the code that simulates the experiment, i.e., every so many
## miliseconds a new item is presented, which has to be stored in DM.
##
## Write the code that performs the rehearsals, and interweave that
## with the stimulus presentation.
##
## Write the code that does the final recall. Keep in mind that that
## phase also takes time...
##
## Put everything in a nice plot.
##
## Hand in the R code + a PDF version of your plot. Make sure that the
## first couple of lines of your R code contain exact instructions on
## how to run your R code to reprodruce the plot. If your R code does
## not include those instructions, we will assume that the code
## doesn't work.
##
## ---------------------------------------------------------------------------
## ---------------------------------------------------------------------------
##
## Template for DM assignment Cognitive Modeling Course
##
## Hedderik van Rijn, 091119
##
## ---------------------------------------------------------------------------
## List with parameter values:
params <- list()
params$d <- .5
## ---------------------------------------------------------------------------
## DM functions
create.dm <- function(chunks,encounters) {
if (chunks > 52) {
stop("Only up to 52 chunks allowed.")
}
DM <- array(NA,c(chunks,encounters))
row.names(DM) <- c(letters,LETTERS)[1:chunks]
DM
}
add.encounter <- function(DM,chunk,time) {
tmp <- DM[chunk,]
DM[chunk,sum(!is.na(tmp))+1] <- time
DM
}
get.encounters <- function(DM,chunk) {
tmp <- DM[chunk,]
tmp[!is.na(tmp)]
}
## ---------------------------------------------------------------------------
## Baselevel activation functions:
## Simple version (only takes a single curtime value)
actr.B <- function(encounters,curtime) {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
## More advanced version, also takes multiple curtime values
actr.B <- function(encounters,curtime) {
if (length(curtime)>1) {
sapply(curtime,function(X) { actr.B(encounters,X)})
} else {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
}
actr.B.optimized <- function(n,Time,curtime=NULL) {
if (is.null(curtime)) {
log(n/(1-params$d)) - params$d * log(Time)
} else {
n <- curtime/Time * n
log(n/(1-params$d)) - params$d * log(curtime)
}
}
## ---------------------------------------------------------------------------
## Some example code to get you started:
params$num.chunks <- 4
params$max.num.encounters <- 100
params$duration <- 1000
## Create a DM with room for num.chunks chunks with up to num.encounters encounters per chunk.
DM <- create.dm(params$num.chunks,params$max.num.encounters)
## Add 100 encounters to DM
for (i in 1:250) {
DM <- add.encounter(DM,letters[trunc(runif(1,1,params$num.chunks+1))],runif(1,0,params$duration))
}
## Calculate the activation per chunk:
for (i in letters[1:params$num.chunks]) {
cat("Activation of chunk ",i," is ");
cat(actr.B(get.encounters(DM,i),params$duration),"\n");
}
## ---------------------------------------------------------------------------
##
## What you have to do:
##
## Write the code that simulates the experiment, i.e., every so many
## miliseconds a new item is presented, which has to be stored in DM.
##
## Write the code that performs the rehearsals, and interweave that
## with the stimulus presentation.
##
## Write the code that does the final recall. Keep in mind that that
## phase also takes time...
##
## Put everything in a nice plot.
##
## Hand in the R code + a PDF version of your plot. Make sure that the
## first couple of lines of your R code contain exact instructions on
## how to run your R code to reprodruce the plot. If your R code does
## not include those instructions, we will assume that the code
## doesn't work.
##
## ---------------------------------------------------------------------------
letters[1:params$num.chunks]
params$num.chunks <- 10
letters[1:params$num.chunks]
params$max.num.encounters <- 100
letters[1:params$num.chunks]
params$num.chunks <- 100
letters[1:params$num.chunks]
help(trunc)
runif(1,1,num.chunks+1)
num.chunks = 100
runif(1,1,num.chunks+1)
letters[trunc(runif(1,1,params$num.chunks+1))]
num.chunks = 4
letters[trunc(runif(1,1,params$num.chunks+1))]
letters[trunc(runif(1,1,num.chunks+1))]
params$num.chunks <- 4
params$max.num.encounters <- 100
params$duration <- 1000
DM <- create.dm(params$num.chunks,params$max.num.encounters)
DM
for (i in 1:250) {
DM <- add.encounter(DM,letters[trunc(runif(1,1,params$num.chunks+1))],runif(1,0,params$duration))
}
DM
runif(1,0,duration)
runif(1,0,param$duration)
runif(1,0,params$duration)
# Time measurement parameters
t_0 = 11            # The starting length of a pulse in ms
a = 1.1             # The growth factor of the pulses
b = 0.015           # Noise influence parameter
# Act-R's noise function
actr.noise <- function(s,n=1) {
rand <- runif(n,min=0.0001,max=0.9999)
s * log((1 - rand ) / rand)
}
# Convert ticks to time and return time (not used in the bisection model but added for completeness sake)
ticksToTime = function(ticks) {
# The starting values, the first pulse length is also subject to noise here
pulseLength = t_0 + actr.noise(b*a*t_0)
measuredTime = 0
# Add the time from every tick and return the total measured time
for(tick in 1:ticks) {
pulseLength = a * pulseLength + actr.noise(b*a*pulseLength)
measuredTime = measuredTime + pulseLength
}
measuredTime
}
# Convert time to ticks and return ticks
timeToTicks = function(time) {
# The starting values, the first pulse length is also subject to noise here
ticks = 0
pulseLength = t_0 + actr.noise(b*a*t_0)
measuredTime = 0
# Until the targetTime is reached, continue to count ticks and return the final count
while(measuredTime < time) {
pulseLength = a * pulseLength + actr.noise(b*a*pulseLength)
measuredTime = measuredTime + pulseLength
ticks = ticks + 1
}
ticks
}
## List with parameter values:
params <- list()
params$d <- .5
## ---------------------------------------------------------------------------
## DM functions
create.dm <- function(chunks,encounters) {
if (chunks > 52) {
stop("Only up to 52 chunks allowed.")
}
DM <- array(NA,c(chunks,encounters))
row.names(DM) <- c(letters,LETTERS)[1:chunks]
DM
}
add.encounter <- function(DM,chunk,time) {
tmp <- DM[chunk,]
DM[chunk,sum(!is.na(tmp))+1] <- time
DM
}
get.encounters <- function(DM,chunk) {
tmp <- DM[chunk,]
tmp[!is.na(tmp)]
}
## ---------------------------------------------------------------------------
## Baselevel activation function:
actr.B <- function(encounters,curtime) {
if (length(curtime)>1) {
sapply(curtime,function(X) { actr.B(encounters,X)})
} else {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
}
## Calculate the activation per chunk:
for (i in letters[1:params$num.chunks]) {
cat("Activation of chunk ",i," is ");
cat(actr.B(get.encounters(DM,i),params$duration),"\n");
}
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 10   # The 'number of subjects'
trainingTrials = 500 # The number of learning trials
trials = 1000 # The number of test trials
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
#
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsTrainData = array(NA, dim = c(nrSubjects, length(priorDists), trainingTrials))
subjectsTestData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function() {
for(subject in 1:nrSubjects) {
# Create the declarative memory of the current subject
num.chunks <- 3 # One chunk for every prior condition (short, medium or long duration)
max.num.encounters <- 500
DM = create.dm(num.chunks,max.num.encounters)
for(priorDist in 1:length(priorDists)) {
for(lTrial in 1:trainingTrials) {
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
# Add the duration of the sample to the chunk of the current condition (measured with timeToTicks and ticksToTime)
DM = add.encounter(DM, priorDist, ticksToTime(timeToTicks(sample)))
}
for(trial in 1:trials){
sample = sample(1:11, 1) # Randomly choose a sample from the distribution
t_s = priorDists[[priorDist]][sample] # The current sample time
# Measure the interval in ticks
timeToTicks(sample)
# Using the previously defined prior determine the estimated time and produced time
}
}
}
}
readySetGo()
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
## ---------------------------------------------------------------------------
##
## Template for DM assignment Cognitive Modeling Course
##
## Hedderik van Rijn, 091119
##
## ---------------------------------------------------------------------------
## List with parameter values:
params <- list()
params$d <- .5
## ---------------------------------------------------------------------------
## DM functions
create.dm <- function(chunks,encounters) {
if (chunks > 52) {
stop("Only up to 52 chunks allowed.")
}
DM <- array(NA,c(chunks,encounters))
row.names(DM) <- c(letters,LETTERS)[1:chunks]
DM
}
add.encounter <- function(DM,chunk,time) {
tmp <- DM[chunk,]
DM[chunk,sum(!is.na(tmp))+1] <- time
DM
}
get.encounters <- function(DM,chunk) {
tmp <- DM[chunk,]
tmp[!is.na(tmp)]
}
## ---------------------------------------------------------------------------
## Baselevel activation functions:
## Simple version (only takes a single curtime value)
actr.B <- function(encounters,curtime) {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
## More advanced version, also takes multiple curtime values
actr.B <- function(encounters,curtime) {
if (length(curtime)>1) {
sapply(curtime,function(X) { actr.B(encounters,X)})
} else {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
}
actr.B.optimized <- function(n,Time,curtime=NULL) {
if (is.null(curtime)) {
log(n/(1-params$d)) - params$d * log(Time)
} else {
n <- curtime/Time * n
log(n/(1-params$d)) - params$d * log(curtime)
}
}
## ---------------------------------------------------------------------------
## Some example code to get you started:
params$num.chunks <- 4
params$max.num.encounters <- 100
params$duration <- 1000
## Create a DM with room for num.chunks chunks with up to num.encounters encounters per chunk.
DM <- create.dm(params$num.chunks,params$max.num.encounters)
## Add 100 encounters to DM
for (i in 1:250) {
DM <- add.encounter(DM,letters[trunc(runif(1,1,params$num.chunks+1))],runif(1,0,params$duration))
}
## Calculate the activation per chunk:
for (i in letters[1:params$num.chunks]) {
cat("Activation of chunk ",i," is ");
cat(actr.B(get.encounters(DM,i),params$duration),"\n");
}
## Plot activation per chunk:
par(mfrow=c(2,2))
for (i in letters[1:params$num.chunks]) {
plot(1,1,type="n",xlim=c(1,params$duration),ylim=c(-4,4),xlab="Time",ylab="Activation",main=paste("chunk",i))
curencounters <- get.encounters(DM,i)
if (length(curencounters)>0) {
lines(actr.B(curencounters,1:params$duration))
}
}
## ---------------------------------------------------------------------------
##
## What you have to do:
##
## Write the code that simulates the experiment, i.e., every so many
## miliseconds a new item is presented, which has to be stored in DM.
##
## Write the code that performs the rehearsals, and interweave that
## with the stimulus presentation.
##
## Write the code that does the final recall. Keep in mind that that
## phase also takes time...
##
## Put everything in a nice plot.
##
## Hand in the R code + a PDF version of your plot. Make sure that the
## first couple of lines of your R code contain exact instructions on
## how to run your R code to reprodruce the plot. If your R code does
## not include those instructions, we will assume that the code
## doesn't work.
##
## ---------------------------------------------------------------------------
DM
## Some example code to get you started:
params$num.chunks <- 4
params$max.num.encounters <- 100
params$duration <- 1000
## Create a DM with room for num.chunks chunks with up to num.encounters encounters per chunk.
DM <- create.dm(params$num.chunks,params$max.num.encounters)
## Add 100 encounters to DM
for (i in 1:250) {
DM <- add.encounter(DM,letters[trunc(runif(1,1,params$num.chunks+1))],runif(1,0,params$duration))
}
## ---------------------------------------------------------------------------
##
## Template for DM assignment Cognitive Modeling Course
##
## Hedderik van Rijn, 091119
##
## ---------------------------------------------------------------------------
## List with parameter values:
params <- list()
params$d <- .5
## ---------------------------------------------------------------------------
## DM functions
create.dm <- function(chunks,encounters) {
if (chunks > 52) {
stop("Only up to 52 chunks allowed.")
}
DM <- array(NA,c(chunks,encounters))
row.names(DM) <- c(letters,LETTERS)[1:chunks]
DM
}
add.encounter <- function(DM,chunk,time) {
tmp <- DM[chunk,]
DM[chunk,sum(!is.na(tmp))+1] <- time
DM
}
get.encounters <- function(DM,chunk) {
tmp <- DM[chunk,]
tmp[!is.na(tmp)]
}
## ---------------------------------------------------------------------------
## Baselevel activation functions:
## Simple version (only takes a single curtime value)
actr.B <- function(encounters,curtime) {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
## More advanced version, also takes multiple curtime values
actr.B <- function(encounters,curtime) {
if (length(curtime)>1) {
sapply(curtime,function(X) { actr.B(encounters,X)})
} else {
if (curtime < min(encounters)) {
return(NA)
} else {
log(sum((curtime - encounters[encounters<curtime])^-params$d))
}
}
}
actr.B.optimized <- function(n,Time,curtime=NULL) {
if (is.null(curtime)) {
log(n/(1-params$d)) - params$d * log(Time)
} else {
n <- curtime/Time * n
log(n/(1-params$d)) - params$d * log(curtime)
}
}
## ---------------------------------------------------------------------------
## Some example code to get you started:
params$num.chunks <- 4
params$max.num.encounters <- 100
params$duration <- 1000
## Create a DM with room for num.chunks chunks with up to num.encounters encounters per chunk.
DM <- create.dm(params$num.chunks,params$max.num.encounters)
## Add 100 encounters to DM
for (i in 1:250) {
DM <- add.encounter(DM,letters[trunc(runif(1,1,params$num.chunks+1))],runif(1,0,params$duration))
}
DM
chunk = a
chunk = "a"
DM[chunk,sum(!is.na(tmp))]
tmp <- DM[chunk,]
sum(!is.na(tmp))
DM[chunk,sum(!is.na(tmp))+1]
min(DM)
DM
min(DM)
get.encounters(DM,i)
get.encounters(DM,1)
for (i in letters[1:params$num.chunks]) {
cat("Activation of chunk ",i," is ");
cat(actr.B(get.encounters(DM,i),params$duration),"\n");
}
for (i in letters[1:params$num.chunks]) {
cat("Activation of chunk ",i," is ");
cat(actr.B(get.encounters(DM,i),params$duration),"\n");
}
for (i in letters[1:params$num.chunks]) {
cat("Activation of chunk ",i," is ");
cat(actr.B(get.encounters(DM,i),params$duration),"\n");
}
