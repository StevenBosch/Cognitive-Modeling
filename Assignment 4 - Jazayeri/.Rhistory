x = priors*c(1:num.chunks)
na.omit(x)
help(na.omit)
sum(x)
sum(x, na.rm=TRUE)
subjectsData[subject][priorDist][trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE)))
subjectsData[subject][priorDist][trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
subjectsData
subjectsData[1]
subjectsData[1][1]
subjectsData[1][1][4]
subjectsData[1][2][4]
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
# Data storage
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trials) {
for(subject in 1:nrSubjects) {
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
# Create the declarative memory of the current subject for the current condition
num.chunks = 30 # The max interval is 1200 ms, which amounts to 25 or 26 ticks, so 30 should be enough
max.num.encounters = trials
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
activation = array(NA, dim=c(num.chunks))
priors = array(NA, dim=c(num.chunks))
# The current time
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time in an internal representation
t_m = timeToTicks(t_s)
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_s # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter at the t_m ticks index
DM = add.encounter(DM, t_m, curtime)
# Calculate activation values for all chunks so far using the current time and the times of the encounters
for(chunk in 1:num.chunks) {
if(!is.na(DM[chunk][1])) {
activation[chunk] = actr.B(DM[chunk], curtime)
}
}
# Calculate the priors with the activations
activationSum = sum(activation, na.rm = TRUE)
for(chunk in 1:num.chunks) {
priors[chunk] = activation[chunk] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject][priorDist][trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
}
}
}
}
readySetGo(nrSubjects, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
subjectsData
subjectsData[1][1]
subjectsData[1]
subjectsData
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
# Data storage
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trials) {
for(subject in 1:nrSubjects) {
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
# Create the declarative memory of the current subject for the current condition
num.chunks = 30 # The max interval is 1200 ms, which amounts to 25 or 26 ticks, so 30 should be enough
max.num.encounters = trials
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
activation = array(NA, dim=c(num.chunks))
priors = array(NA, dim=c(num.chunks))
# The current time
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time in an internal representation
t_m = timeToTicks(t_s)
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_s # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter at the t_m ticks index
DM = add.encounter(DM, t_m, curtime)
# Calculate activation values for all chunks so far using the current time and the times of the encounters
for(chunk in 1:num.chunks) {
if(!is.na(DM[chunk][1])) {
activation[chunk] = actr.B(DM[chunk], curtime)
}
}
# Calculate the priors with the activations
activationSum = sum(activation, na.rm = TRUE)
for(chunk in 1:num.chunks) {
priors[chunk] = activation[chunk] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject][priorDist][trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
}
}
}
}
readySetGo(nrSubjects, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
warnings()
x = array(1:50, c(10,10,30))
x
x[1]
x[1][1][3]
x[[1]]
x[[[1]]
x[1,1,3]
x[1,1,8]
x[1,3,8]
x[1,2,30]
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
# Data storage
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trials) {
for(subject in 1:nrSubjects) {
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
# Create the declarative memory of the current subject for the current condition
num.chunks = 30 # The max interval is 1200 ms, which amounts to 25 or 26 ticks, so 30 should be enough
max.num.encounters = trials
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
activation = array(NA, dim=c(num.chunks))
priors = array(NA, dim=c(num.chunks))
# The current time
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time in an internal representation
t_m = timeToTicks(t_s)
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_s # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter at the t_m ticks index
DM = add.encounter(DM, t_m, curtime)
# Calculate activation values for all chunks so far using the current time and the times of the encounters
for(chunk in 1:num.chunks) {
if(!is.na(DM[chunk][1])) {
activation[chunk] = actr.B(DM[chunk], curtime)
}
}
# Calculate the priors with the activations
activationSum = sum(activation, na.rm = TRUE)
for(chunk in 1:num.chunks) {
priors[chunk] = activation[chunk] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject, priorDist, trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
}
}
}
}
readySetGo(nrSubjects, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
subjectsData[1,1,]
subjectsData[,,]
activation
ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
subjectsData[1,1,40]
subjectsData[1,1,40] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
subjectsData
subjectsData[,,,]
subjectsData[,,]
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
# Data storage
subjectsPriors = array(NA, dim = c(nrSubjects, length(priorDists), 2)) # per prior distribution a stored mean and sd
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
readySetGo = function(nrSubjects, trials) {
for(subject in 1:nrSubjects) {
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
# Create the declarative memory of the current subject for the current condition
num.chunks = 30 # The max interval is 1200 ms, which amounts to 25 or 26 ticks, so 30 should be enough
max.num.encounters = trials
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
activation = array(NA, dim=c(num.chunks))
priors = array(NA, dim=c(num.chunks))
# The current time
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time in an internal representation
t_m = timeToTicks(t_s)
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_s # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter at the t_m ticks index
DM = add.encounter(DM, t_m, curtime)
# Calculate activation values for all chunks so far using the current time and the times of the encounters
for(chunk in 1:num.chunks) {
if(!is.na(DM[chunk][1])) {
activation[chunk] = actr.B(DM[chunk], curtime)
}
}
# Calculate the priors with the activations
activationSum = sum(activation, na.rm = TRUE)
for(chunk in 1:num.chunks) {
priors[chunk] = activation[chunk] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject, priorDist, trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
}
}
}
}
readySetGo(nrSubjects, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
readySetGo(nrSubjects, trials)
readySetGo(nrSubjects, trials)
x = readySetGo(nrSubjects, trials)
x
subjectsData
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
readySetGo = function(nrSubjects, trials) {
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists), trials))
for(subject in 1:nrSubjects) {
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
# Create the declarative memory of the current subject for the current condition
num.chunks = 30 # The max interval is 1200 ms, which amounts to 25 or 26 ticks, so 30 should be enough
max.num.encounters = trials
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
activation = array(NA, dim=c(num.chunks))
priors = array(NA, dim=c(num.chunks))
# The current time
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
t_s = priorDists[[priorDist]][sample(1:11, 1)]
# Measure the sample time in an internal representation
t_m = timeToTicks(t_s)
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_s # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter at the t_m ticks index
DM = add.encounter(DM, t_m, curtime)
# Calculate activation values for all chunks so far using the current time and the times of the encounters
for(chunk in 1:num.chunks) {
if(!is.na(DM[chunk][1])) {
activation[chunk] = actr.B(DM[chunk], curtime)
}
}
# Calculate the priors with the activations
activationSum = sum(activation, na.rm = TRUE)
for(chunk in 1:num.chunks) {
priors[chunk] = activation[chunk] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject, priorDist, trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
}
}
}
subjectsData
}
data = readySetGo(nrSubjects, trials)
# First stage: determine measured time from the sample time:
# Gaussian: t_measured -> p(t_measured|t_sample) (sd grows linearly with mean)
# Second stage: determine estimated time from the measured time:
# t_estimated = f(t_measured)
# Third stage: produce interval from the estimated time:
# Gaussian: t_produced -> p(t_produced|t_estimated) (sd grows linearly with mean)
data
load("dataJS.Rdat");
dataJS.dat
dataJS.Rdat
par(mfrow=c(1,1))
plotDatJS <- with(datJS,aggregate(list(Tp=Tp),list(Ts=Ts,Cond=Cond),mean))
plotDatJS
yrange <- range(plotDatJS$Ts)*c(.95,1.05)
with(plotDatJS[plotDatJS$Cond==3,],plot(Ts,Tp,type="b",col=red,lwd=2,ylim=yrange,xlim=yrange,main="J&S All"))
with(plotDatJS[plotDatJS$Cond==2,],lines(Ts,Tp,type="b",col=brown,lwd=2,ylim=yrange,xlim=yrange))
with(plotDatJS[plotDatJS$Cond==1,],lines(Ts,Tp,type="b",col=black,lwd=2,ylim=yrange,xlim=yrange))
lines(c(yrange[1],yrange[2]),c(yrange[1],yrange[2]),col="darkgrey",lty=2)
with(datJS[datJS$Cond==3,],points(jitter(Ts),Tp,col=redT,pch=".",cex=3))
with(datJS[datJS$Cond==2,],points(jitter(Ts),Tp,col=brownT,pch=".",cex=3))
with(datJS[datJS$Cond==1,],points(jitter(Ts),Tp,col=blackT,pch=".",cex=3))
## ---------------------------------------------------------------------------
##
## Some code to plot the Jazayeri & Shadlen (2010) data
##
## Hedderik van Rijn, December 2015
##
## ---------------------------------------------------------------------------
load("dataJS.Rdat");
brown <- "#8b4513";
red <- "#ff1100";
black <- "#000000";
brownT <- "#8b451322";
redT <- "#ff110022";
blackT <- "#00000022";
## ---
par(mfrow=c(1,1))
plotDatJS <- with(datJS,aggregate(list(Tp=Tp),list(Ts=Ts,Cond=Cond),mean))
yrange <- range(plotDatJS$Ts)*c(.95,1.05)
with(plotDatJS[plotDatJS$Cond==3,],plot(Ts,Tp,type="b",col=red,lwd=2,ylim=yrange,xlim=yrange,main="J&S All"))
with(plotDatJS[plotDatJS$Cond==2,],lines(Ts,Tp,type="b",col=brown,lwd=2,ylim=yrange,xlim=yrange))
with(plotDatJS[plotDatJS$Cond==1,],lines(Ts,Tp,type="b",col=black,lwd=2,ylim=yrange,xlim=yrange))
lines(c(yrange[1],yrange[2]),c(yrange[1],yrange[2]),col="darkgrey",lty=2)
with(datJS[datJS$Cond==3,],points(jitter(Ts),Tp,col=redT,pch=".",cex=3))
with(datJS[datJS$Cond==2,],points(jitter(Ts),Tp,col=brownT,pch=".",cex=3))
with(datJS[datJS$Cond==1,],points(jitter(Ts),Tp,col=blackT,pch=".",cex=3))
source("DM-module.R", TRUE)
source("time.R", TRUE)
# Experiment setup parameters
nrSubjects = 1   # The 'number of subjects'
trials = 500 # The total number of trials, it depends on which trials you plot, how many of these you consider as `training' trials
# Experiment durations, for calculating the activation of the chunks
FixPointDuration = 1000
delayLowerBound = 250
delayUpperBound = 850
# Create the prior distributions
priorDist1 = seq(from = 494, to = 847, by = (847-494)/10)
priorDist2 = seq(from = 671, to = 1023, by = (1023-671)/10)
priorDist3 = seq(from = 847, to = 1200, by = (1200-847)/10)
priorDists = list(priorDist1, priorDist2, priorDist3)
# The readySetGo experiment
readySetGo = function(nrSubjects, trials) {
subjectsData = array(NA, dim = c(nrSubjects, length(priorDists),2 , trials))
for(subject in 1:nrSubjects) {
# For every condition (short, medium, long)
for(priorDist in 1:length(priorDists)) {
# Create the declarative memory of the current subject for the current condition
num.chunks = 30 # The max interval is 1200 ms, which amounts to 25 or 26 ticks, so 30 should be enough
max.num.encounters = trials
DM = create.dm(num.chunks,max.num.encounters)
# Temporary storage stuff
activation = array(NA, dim=c(num.chunks))
priors = array(NA, dim=c(num.chunks))
# The current time
curtime = 0 # Keep track of the time during the experiment, to account for activation decrease
# Perform the trials
for(trial in 1:trials) {
# The current sample time
sample = sample(1:11, 1)
t_s = priorDists[[priorDist]][sample]
subjectsData[subject, priorDist, 1, trial] = t_s # store it
# Measure the sample time in an internal representation
t_m = timeToTicks(t_s)
# Determine the current time with the values used in the paper for delay time and fixation point duration
delay = sample(250:850, 1)
curtime = curtime + delay + FixPointDuration + t_s # The current time, given that the first trial was at time == 0 ms
# Add the time the trial takes place as an encounter at the t_m ticks index
DM = add.encounter(DM, t_m, curtime)
# Calculate activation values for all chunks so far using the current time and the times of the encounters
for(chunk in 1:num.chunks) {
if(!is.na(DM[chunk][1])) {
activation[chunk] = actr.B(DM[chunk], curtime)
}
}
# Calculate the priors with the activations
activationSum = sum(activation, na.rm = TRUE)
for(chunk in 1:num.chunks) {
priors[chunk] = activation[chunk] / activationSum
}
# Determine the estimated time by multiplying the priors of all encounters with their measured duration
subjectsData[subject, priorDist, 2, trial] = ticksToTime(sum(priors*c(1:num.chunks), na.rm = TRUE))
}
}
}
subjectsData
}
data = readySetGo(nrSubjects, trials)
data
data[1,1,,]
help(wit)
help(with)
with(data[1,3,1,],plot(data[1,3,1,], data[1,3,2,],type="b",col=red,lwd=2,ylim=yrange,xlim=yrange,main="J&S All"))
plot(data[1,3,1,], data[1,3,2,],type="b",col=red,lwd=2,ylim=yrange,xlim=yrange,main="J&S All")
plotDat = with(data,aggregate(list(Tp=Tp),list(Ts=Ts,Cond=Cond),mean))
plotDat = aggregate(list(Tp=Tp),list(Ts=Ts,Cond=Cond),mean)
lines(data[1,2,1,],data[1,2,2,],type="b",col=brown,lwd=2,ylim=yrange,xlim=yrange)
lines(data[1,1,1,],data[1,1,2,],type="b",col=black,lwd=2,ylim=yrange,xlim=yrange)
lines(c(yrange[1],yrange[2]),c(yrange[1],yrange[2]),col="darkgrey",lty=2)
points(jitter(data[1,3,1,]),data[1,3,2,],col=redT,pch=".",cex=3)
points(jitter(data[1,2,1,]),data[1,2,2,],col=brownT,pch=".",cex=3)
points(jitter(data[1,1,1,]),data[1,1,2,],col=blackT,pch=".",cex=3)
plot(data[1,3,1,], data[1,3,2,],type="b",col=red,lwd=2,ylim=yrange,xlim=yrange,main="J&S All")
points(jitter(data[1,3,1,]),data[1,3,2,],col=redT,pch=".",cex=3)
points(jitter(data[1,2,1,]),data[1,2,2,],col=brownT,pch=".",cex=3)
points(jitter(data[1,1,1,]),data[1,1,2,],col=blackT,pch=".",cex=3)
## ---------------------------------------------------------------------------
load("dataJS.Rdat");
brown <- "#8b4513";
red <- "#ff1100";
black <- "#000000";
brownT <- "#8b451322";
redT <- "#ff110022";
blackT <- "#00000022";
## ---
par(mfrow=c(1,1))
plotDatJS <- with(datJS,aggregate(list(Tp=Tp),list(Ts=Ts,Cond=Cond),mean))
yrange <- range(plotDatJS$Ts)*c(.95,1.05)
with(plotDatJS[plotDatJS$Cond==3,],plot(Ts,Tp,type="b",col=red,lwd=2,ylim=yrange,xlim=yrange,main="J&S All"))
with(plotDatJS[plotDatJS$Cond==2,],lines(Ts,Tp,type="b",col=brown,lwd=2,ylim=yrange,xlim=yrange))
with(plotDatJS[plotDatJS$Cond==1,],lines(Ts,Tp,type="b",col=black,lwd=2,ylim=yrange,xlim=yrange))
lines(c(yrange[1],yrange[2]),c(yrange[1],yrange[2]),col="darkgrey",lty=2)
with(datJS[datJS$Cond==3,],points(jitter(Ts),Tp,col=redT,pch=".",cex=3))
with(datJS[datJS$Cond==2,],points(jitter(Ts),Tp,col=brownT,pch=".",cex=3))
with(datJS[datJS$Cond==1,],points(jitter(Ts),Tp,col=blackT,pch=".",cex=3))
help(aggregate)
data = readySetGo(nrSubjects, trials)
rownames(x) = subject
rownames(x) = "subject"
rownames(data) = "subject"
data
rownames(data) = "Subj"
rownames(data[,]) = "Cond"
rownames(data[,,,]) = "Cond"
